// Do this as the first thing so that any code reading it knows the right env.
process.env.BABEL_ENV = 'development';
process.env.NODE_ENV = 'development';

// Makes the script crash on unhandled rejections instead of silently
// ignoring them. In the future, promise rejections that are not handled will
// terminate the Node.js process with a non-zero exit code.
process.on('unhandledRejection', err => {
    throw err;
});

let host = 'localhost';
let port = 3000;

process.argv.forEach(arg => {
    if (arg.indexOf("port:") === 0) {
        port = arg.slice(5)
    } else if (arg.indexOf("host:") === 0) {
        host = arg.slice(5)
    } else if (arg.indexOf("path:") === 0) {
        process.env.HSTEST_STAGE_PATH = arg.slice(5);
    }
});

// Ensure environment variables are read.
require('./config/env');


const webpack = require('webpack');
const WebpackDevServer = require('webpack-dev-server');
const {
    prepareUrls,
    createCompiler,
    prepareProxy
} = require('react-dev-utils/WebpackDevServerUtils');
const detect = require('detect-port-alt');

const paths = require('./config/paths');
const configFactory = require('./config/webpack.config');
const createDevServerConfig = require('./config/webpackDevServer.config');

const isInteractive = process.stdout.isTTY;




// We require that you explicitly set browsers and do not fall back to
// browserslist defaults.
const config = configFactory('development');
const appName = require(paths.appPackageJson).name;
const tscCompileOnError = process.env.TSC_COMPILE_ON_ERROR === 'true';

detect(port, host).then(
    new_port => {
        if (new_port == null) {
            // We have not found a port.
            return;
        }
        port = new_port

        const urls = prepareUrls(
            "http",
            host,
            port,
            paths.publicUrlOrPath.slice(0, -1)
        );

        const devSocket = {
            warnings: warnings => devServer.sockWrite(devServer.sockets, 'warnings', warnings),
            errors: errors => devServer.sockWrite(devServer.sockets, 'errors', errors),
        };

// Create a webpack compiler that is configured with custom messages.
        const compiler = createCompiler({
            appName,
            config,
            devSocket,
            urls,
            useYarn: false,
            useTypeScript: false,
            tscCompileOnError,
            webpack,
        });

// Load proxy config
        const proxySetting = require(paths.appPackageJson).proxy;
        const proxyConfig = prepareProxy(
            proxySetting,
            paths.appPublic,
            paths.publicUrlOrPath
        );

// Serve webpack assets generated by the compiler over a web server.
        const serverConfig = createDevServerConfig(
            proxyConfig
        );
        const devServer = new WebpackDevServer(compiler, serverConfig);

// Launch WebpackDevServer.
        devServer.listen(new_port, host, err => {
            if (err) {
                return console.log(err);
            }
            if (isInteractive) {
                process.stdout.write(
                    process.platform === 'win32' ? '\x1B[2J\x1B[0f' : '\x1B[2J\x1B[3J\x1B[H'
                );
            }
        });

        ['SIGINT', 'SIGTERM'].forEach(function (sig) {
            process.on(sig, function () {
                devServer.close();
                process.exit();
            });
        });

        if (isInteractive || process.env.CI !== 'true') {
            process.stdin.on('end', function () {
                devServer.close();
                process.exit();
            });
            process.stdin.resume();
        }
    })
.catch(err => {
    if (err && err.message) {
        console.log(err.message);
    }
    process.exit(1);
});
